5. 写入流程 (Write Flow)

采用先写入临时目录，成功后移动到正式目录的方式，保证原子性。
不再依赖 `jdb_fs::AtomWrite`，而是显式管理 `tmp/` 和 `sst/` 目录。

5.1 Writer 状态

struct Writer {
    builder: BlockBuilder,   // 当前 block 构建器
    block_size: usize,
    epsilon: usize,
    compress: Compress,
    hashes: Vec<u64>,        // filter 用
    first_keys: Vec<Box<[u8]>>,
    offsets: Vec<u64>,
    file_offset: u64,
    meta: Meta,
    max_ver: u64,
    rmed_size: u64,
    level: u8,
    // Add file handle or path info if needed, or pass it to write function
}


5.2 写入步骤

1. **生成路径**: 
   - 使用 `ider` 生成唯一 id 和文件名 (e.g. `14pc0mi`)。
   - 临时路径: `tmp_path = tmp_dir.join(name)`
   - 目标路径: `sst_path = sst_dir.join(name)`

2. **创建文件**:
   - `File::create(&tmp_path).await?` 创建临时文件。

3. **写入数据 (遍历 KV 流)**:
   a. builder.add(key, pos)
   b. hashes.push(gxhash64(key, 0))
   c. 更新 max_ver, rmed_size
   d. 若 builder.size() >= block_size:
      - 记录 first_key 和 offset
      - builder.build_encoded() 生成 block 数据
      - file.write_all(block_data)
      - file_offset += block_data.len()

4. **Flush 最后一个 Block**:
   - 如果 builder 非空，生成并写入最后一个 block。

5. **写入元数据 (Filter/Index/Foot)**:
   - 构建 filter: BinaryFuse8::try_from(&hashes)
   - 构建 pgm: Pgm::new(&data, epsilon, false)
   - 序列化并压缩 filter/index
   - 写入 filter_data, index_data
   - 构建并写入 Foot (checksum 覆盖必要部分)

6. **原子提交**:
   - `file.sync_all().await?` 确保数据持久化。
   - `fs::rename(tmp_path, sst_path).await?` 将文件从 tmp 移到 sst 目录。
   - `File::open(sst_dir).sync_all().await?` (可选，确保目录元数据持久化)



5.3 BlockBuilder (复用旧版)

struct BlockBuilder {
    key_arena: Vec<u8>,
    entries: Vec<(u32, u16, Pos)>,  // (offset, len, pos)
    restart_interval: usize,
    item_count: usize,
    restarts: Vec<u32>,
    buf: Vec<u8>,
    estimated_size: usize,
}

方法:
- add(key, pos): 添加 KV
- build_encoded(): 生成带前缀压缩的 block 数据
- reset(): 重置复用
