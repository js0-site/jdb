2. 核心结构 (Core Structures)

2.1 Sst (Manager)

实现 jdb_base::Sst trait，管理多个 SstFile。



struct Sst<C> {
    ckp: C,                 // Checkpoint manager
    lru: FileLru,           // 文件管理器 (包含 dir 和 cache)
    sst_dir: PathBuf,       // sst/ 子目录
    tmp_dir: PathBuf,       // tmp/ 子目录
    files: Vec<SstFile>,    // 按 id 降序，新文件在前
    config: Config,         // 解析后的配置
}

impl<C: jdb_base::sst::ckp::Ckp> Sst<C> {
    pub fn new(dir: impl Into<PathBuf>, ckp: C, conf_li: &[Conf]) -> Self {
        let lru = FileLru::new(dir);
        let config = Config::from(conf_li);
        // 1. 初始化 sst_dir, tmp_dir (基于 lru.dir)
        // 2. 确保目录存在
        // 3. 加载 sst_dir 下的所有 sst 文件
        // 4. 清理 tmp_dir
        todo!()
    }
}

impl<C: jdb_base::sst::ckp::Ckp> jdb_base::Sst for Sst<C>:
  - write(): 接收 Iterator<Item=Kv>，在 tmp_dir 生成新文件，完成后移动到 sst_dir
  - push(): 将 Meta 加入管理列表


2.2 SstFile (Single File Handle)

单个 SST 文件的内存表示，加载时读取 Index/Filter 常驻内存。

struct SstFile {
    id: u64,
    meta: Meta,              // jdb_base::sst::Meta
    filter: BinaryFuse8,     // xor filter
    pgm: Option<Pgm<u64>>,   // pgm index (block_count > 1 时有效)
    prefix_len: u8,          // pgm 的公共前缀长度
    first_keys: Vec<Box<[u8]>>,  // 每个 block 的首 key
    offsets: Vec<u64>,       // 每个 block 的文件偏移
    data_end: u64,           // data block 区域结束位置
    compress: Compress,      // 压缩算法 (None/LZ4/ZSTD)
}

注意: SstFile 不持有 File 句柄，Sst 在查询时从 lru.cache 获取句柄并传入。


2.3 FileLru (File Manager)

管理根目录和文件句柄缓存。

struct FileLru {
    pub dir: PathBuf,
    pub cache: RefCell<Lru<u64, File>>,
}

impl FileLru {
    pub fn new(dir: impl Into<PathBuf>) -> Self { ... }
    pub fn get(&self, id: u64) -> Result<File> { ... }
}





2.3 Compress 枚举

#[repr(u8)]
enum Compress {
    None = 0,
    Lz4 = 1,
    Zstd = 2,
}


2.4 Conf 配置 (Configuration)

对应文件: src/conf.rs

/// 默认值模块
pub mod default {
    pub const BLOCK_SIZE: usize = 16 * 1024;
    pub const PGM_EPSILON: usize = 16;
    pub const RESTART_INTERVAL: usize = 16;
}

/// 配置选项枚举 (用于传参)
#[derive(Debug, Clone, Copy)]
pub enum Conf {
    BlockSize(usize),       // 默认 16KB
    PgmEpsilon(usize),      // 默认 16
    RestartInterval(usize), // 默认 16
    Compress(Compress),     // 默认 None
}

/// 内部配置结构体 (解析 Conf 列表后生成)
#[derive(Debug, Clone)]
pub struct Config {
    pub block_size: usize,
    pub pgm_epsilon: usize,
    pub restart_interval: usize,
    pub compress: Compress,
}

impl From<&[Conf]> for Config {
    fn from(conf_li: &[Conf]) -> Self {
        // 使用 default 值初始化，遍历 conf_li 覆盖
        todo!()
    }
}



2.5 文件路径生成 (File Path Generation)

使用 ider::path::new 创建 SST 文件 id 和文件名:

// 1. 生成 id 和 base32 编码的文件名
let (id, name) = ider::path::new(&self.lru.dir); 
// 注意: ider::path::new 默认使用 dir，这里可能需要拆分逻辑或仅使用其 id 生成部分。
// 实际上，我们应该只需生成 id 和 name。

文件命名规则:
- 使用 Crockford Base32 编码 id
- 示例: id=1234567890 -> "14pc0mi"

路径:
- 临时文件: "{tmp_dir}/{name}"
- 正式文件: "{sst_dir}/{name}"

